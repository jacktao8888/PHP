#封装：
      就是把对象的成员（属性、方法）结合成一个独立的单位，并尽可能隐藏对象的内部细节，只保留有限对外接口与外界联系
  private 修饰：隐藏起来，只能在对象内部访问，不能在对象外部访问
                属性封装
                方法封装
              
  只要一个变量，需要在多个方法中使用，就将这个变量声明为成员属性，相当于这个对象的全局变量
##和封装有关的魔术方法
封装的成员属性和方法不能被修改或访问，但是可以通过下面的魔术方法实现访问：
  __set();    直接设置私有成员属性时，自动调用的方法
  __get();    直接获取私有成员属性时，自动调用的方法
  __isset();  这样才能用isset()查看私有成员属性
  __unset();  这样才能用unset()删除私有成员属性
  
  private function __get($parName){
    return $this->$parName;       //这里的parName前一定要有"$"，是对象传进来的变量值，否则会被当成对象的全局变量
  }
  private function __set($parName,$parValue){
    $this->$parName=$parValue;
  }
  
#继承
  声明一个子类，用extends继承（扩展）一个父类
##访问类型控制：
  1、子类可以从父类中继承所有内容，包括成员属性、成员方法、构造方法...但private成员只能在本类中使用，子类中也不能使用；
  2、封装时，既可以让自己类的内部使用，也可以让子类内部使用，但类的外部不能使用，private ===> protected
##子类中重载父类的方法
  1、子类可以声明和父类相同的方法名，即子类中覆盖了父类中同名的方法
  2、子类中调用父类中被覆盖的方法：
            父类名::方法名();
            parent::方法名(); //如果父类名改变了，这里不用改变了
      如：
            function say(){
                  parent::say();
                  echo "";
            }
      数组的键=>值 | 对象->成员 | 父类::方法
  注意：
        1、在子类中编写构造方法，如果父类中也有构造方法，一定要去调用一次父类中被覆盖的那个构造方法！！！
           否则，父类中的一些成员属性没有初始化上，子类中也就用不了了。。。
        2、子类中重载的方法，不能低于父类中这个方法的访问权限
    如：
      function __construct($name,$age,$sex,$school){
            parent::__construct($name,$age,$sex);
            $this->school=$school;
      }
            
      
  
 
